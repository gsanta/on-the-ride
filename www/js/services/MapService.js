// Generated by CoffeeScript 1.7.1
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  angular.module("services").factory("Map", function(DataProvider, LocalDataProviderService, MapConstants, Coord) {
    var factoryObj, mapZoomDiameterSquares;
    mapZoomDiameterSquares = [5825, 1456.25, 364.0625, 91.016, 22.754, 5.691, 1.422, 0.3557, 0.0892];
    factoryObj = {
      calculateZoom: function(topLeftCoord, bottomRightCoord) {
        var actDistanceSquare, dist, index, lat1, lat2, lon1, lon2, _i, _len;
        lon1 = parseFloat(topLeftCoord.lon);
        lon2 = parseFloat(bottomRightCoord.lon);
        lat1 = parseFloat(topLeftCoord.lat);
        lat2 = parseFloat(bottomRightCoord.lat);
        actDistanceSquare = Math.pow(lon1 - lon2, 2) + Math.pow(lat1 - lat2, 2);
        for (index = _i = 0, _len = mapZoomDiameterSquares.length; _i < _len; index = ++_i) {
          dist = mapZoomDiameterSquares[index];
          if (dist < actDistanceSquare) {
            if (index === 0) {
              return 1;
            } else {
              return index;
            }
          }
        }
        return mapZoomDiameterSquares.length;
      },
      createMapProperties: function(centerPosition, zoom, mapTypeId) {
        var mapProp;
        mapProp = {
          center: centerPosition,
          zoom: zoom,
          mapTypeId: google.maps.MapTypeId.TERRAIN
        };
        if (mapTypeId != null) {
          mapProp.mapTypeId = mapTypeId;
        }
        return mapProp;
      },
      fetchRouteNodes: function(zoom, maps) {
        return DataProvider.loadRouteInfo(zoom, maps);
      },
      createRouteFromNodeArray: function(nodeArray, zoom, mapIds) {
        var createRouteFromStartNode, finalRoute, i, mapId, n, node, nodeAssocMap, route, startNode, startNodes, _i, _j, _k, _l, _len, _len1, _len2, _len3;
        if (zoom > MapConstants.max_zoom) {
          throw new Error("zoom is bigger than the maximum (use MapConstants.max_zoom)");
        }
        if (zoom < 1) {
          throw new Error("zoom is smaller than the minimum (use MapConstants.min_zoom)");
        }
        createRouteFromStartNode = function(startNode) {
          var actNode, route;
          route = [];
          actNode = startNode;
          while (actNode !== void 0) {
            route.push(actNode);
            if (actNode.weight < zoom) {
              actNode = nodeAssocMap[actNode.siblings[0]];
            } else {
              actNode = nodeAssocMap[actNode.siblings[MapConstants.max_zoom - zoom]];
            }
          }
          return route;
        };
        nodeAssocMap = {};
        for (_i = 0, _len = nodeArray.length; _i < _len; _i++) {
          node = nodeArray[_i];
          nodeAssocMap[node._id] = node;
        }
        startNodes = [];
        for (_j = 0, _len1 = mapIds.length; _j < _len1; _j++) {
          mapId = mapIds[_j];
          startNode = this.getStartNodeFromNodesAtMap(nodeArray, mapId);
          if (startNode) {
            startNodes.push(startNode);
          }
        }
        finalRoute = [];
        for (_k = 0, _len2 = startNodes.length; _k < _len2; _k++) {
          startNode = startNodes[_k];
          route = createRouteFromStartNode(startNode);
          if (route.length > finalRoute.length) {
            finalRoute = route;
          }
        }
        for (i = _l = 0, _len3 = finalRoute.length; _l < _len3; i = ++_l) {
          n = finalRoute[i];
          if (n === void 0) {
            console.log("undef at " + i);
          }
        }
        return finalRoute;
      },
      getStartNodeFromNodesAtMap: function(nodes, mapId) {
        var node, _i, _len;
        for (_i = 0, _len = nodes.length; _i < _len; _i++) {
          node = nodes[_i];
          if (__indexOf.call(node.startNodeInMap, mapId) >= 0) {
            return node;
          }
        }
        return void 0;
      },
      createPolylineFromRoute: function(route) {
        var coordinates, node, routePolyline, _i, _len;
        coordinates = [];
        for (_i = 0, _len = route.length; _i < _len; _i++) {
          node = route[_i];
          coordinates.push(new google.maps.LatLng(node.lat, node.lon));
        }
        routePolyline = new google.maps.Polyline({
          path: coordinates,
          geodesic: true,
          strokeColor: '#FF0000',
          strokeOpacity: 1.0,
          strokeWeight: 2
        });
        return routePolyline;
      },
      createPointsFromRoute: function(route, googleMap) {
        var circle, circles, index, node, pointOptions, _i, _len;
        circles = [];
        for (index = _i = 0, _len = route.length; _i < _len; index = ++_i) {
          node = route[index];
          pointOptions = {
            strokeColor: '#FF0000',
            strokeOpacity: 0.8,
            strokeWeight: 2,
            fillColor: '#FF0000',
            fillOpacity: 0.35,
            draggable: true,
            map: googleMap,
            center: new google.maps.LatLng(node.lat, node.lon),
            radius: (Math.random() * 10) + 10
          };
          circle = new google.maps.Circle(pointOptions);
          circle._id = node._id;
          circles.push(circle);
        }
        return circles;
      },
      addPointToCenterOfMap: function(googleMap) {
        var circle, pointOptions;
        pointOptions = {
          strokeColor: '#00FF00',
          strokeOpacity: 0.8,
          strokeWeight: 2,
          fillColor: '#00FF00',
          fillOpacity: 0.35,
          draggable: true,
          map: googleMap,
          center: googleMap.getCenter(),
          radius: (Math.random() * 10) + 10
        };
        circle = new google.maps.Circle(pointOptions);
        circle._id = -1;
        return circle;
      },
      createCoordinate: function(lat, lon) {
        return new google.maps.LatLng(lat, lon);
      },
      calculateMapIdForNodeAtZoom: function(coord, zoom) {
        var column, distFromLatStart, distFromLonStart, index, latFullLen, latLenAtZoom, lonFullLen, lonLenAtZoom, mapIdOffset, row, rowsColumnsAtZoom, _i;
        if (coord.lon >= MapConstants.lonEnd) {
          coord.lon = MapConstants.lonEnd - 0.00001;
        } else if (coord.lon < MapConstants.lonStart) {
          coord.lon = MapConstants.lonStart;
        }
        if (coord.lat <= MapConstants.latEnd) {
          coord.lat = MapConstants.latEnd + 0.00001;
        } else if (coord.lat > MapConstants.latStart) {
          coord.lat = MapConstants.latStart;
        }
        rowsColumnsAtZoom = Math.pow(2, zoom);
        latFullLen = Math.abs(MapConstants.latStart - MapConstants.latEnd);
        lonFullLen = Math.abs(MapConstants.lonStart - MapConstants.lonEnd);
        distFromLatStart = Math.abs(MapConstants.latStart - coord.lat);
        distFromLonStart = Math.abs(MapConstants.lonStart - coord.lon);
        latLenAtZoom = latFullLen / rowsColumnsAtZoom;
        lonLenAtZoom = lonFullLen / rowsColumnsAtZoom;
        row = Math.floor(distFromLatStart / latLenAtZoom) + 1;
        column = Math.floor(distFromLonStart / lonLenAtZoom) + 1;
        mapIdOffset = 0;
        for (index = _i = 0; 0 <= zoom ? _i < zoom : _i > zoom; index = 0 <= zoom ? ++_i : --_i) {
          mapIdOffset += Math.pow(4, index);
        }
        return mapIdOffset + (row - 1) * rowsColumnsAtZoom + column - 1;
      },
      getMapsForAreaAtZoom: function(topLeftCoord, bottomRightCoord, zoom) {
        var blId, bottomLeftCoord, brId, ids, k, set, tlId, topRightCoord, trId, v;
        bottomLeftCoord = new Coord(topLeftCoord.lon, bottomRightCoord.lat);
        topRightCoord = new Coord(bottomRightCoord.lon, topLeftCoord.lat);
        tlId = this.calculateMapIdForNodeAtZoom(topLeftCoord, zoom);
        trId = this.calculateMapIdForNodeAtZoom(topRightCoord, zoom);
        blId = this.calculateMapIdForNodeAtZoom(bottomLeftCoord, zoom);
        brId = this.calculateMapIdForNodeAtZoom(bottomRightCoord, zoom);
        set = {};
        set[tlId] = 1;
        set[trId] = 1;
        set[blId] = 1;
        set[brId] = 1;
        ids = [];
        for (k in set) {
          v = set[k];
          ids.push(parseInt(k, 10));
        }
        return ids;
      },
      savePoints: function(circles) {
        var circle, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = circles.length; _i < _len; _i++) {
          circle = circles[_i];
          _results.push(LocalDataProviderService.updateNode(circle._id, {
            lat: circle.center.lat(),
            lon: circle.center.lng()
          }));
        }
        return _results;
      },
      addPoints: function(circles) {
        var circle, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = circles.length; _i < _len; _i++) {
          circle = circles[_i];
          _results.push(LocalDataProviderService.addNode({
            lat: circle.center.lat(),
            lon: circle.center.lng()
          }));
        }
        return _results;
      }
    };
    return factoryObj;
  });

}).call(this);
